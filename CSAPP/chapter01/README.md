[TOC]
# 1 计算机系统漫游
## 1.1 信息就是位+上下文
源程序实际上就是一由0和1组成的位（又成为比特）序列，8个位成一组，成为字节。字节表达程序中的字符。

## 1.2 程序被其它程序翻译成不同的格式
翻译过程分为四个阶段
* 预处理阶段
* 编译阶段
* 汇编阶段
* 链接阶段

## 1.3 了解编译系统如何工作的益处
* 优化程序性能
* 理解链接时出现的错误
* 避免安全漏洞

## 1.4 处理器读并解析存储在内存中的指令
理解运行hello程序时发生了什么？
* 系统的硬件组成
1. 总线：贯穿整个系统的一组电子管道
2. I/O设备：是系统与外部世界的联系通道
3. 主存：临时存储设备
4. 处理器：解释存储在主存中的指令的引擎
* 运行hello程序
1. 初始时，从键盘上读取hello命令，shell程序将字符读入寄存器，再把它放到内存中
2. 当敲回车时，shell程序知道输入完毕。然后执行的hello文件，这些命令将目标文件的代码和数据从磁盘复制到内存
3. 一旦目标文件中的代码和数据加载到主存，处理器就开始执行程序中的main。将字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备

## 1.5 高速缓存至关重要（cache）
示例揭示了一个重要的问题，即系统花费了大量时间把信息从一个地方挪到另外一个地方。
程序的机器指令最初是放在磁盘上，程序加载时，被复制到主存；当处理器运行程序时，指令从主存复制到处理器。
因此，系统设计者的一个主要目标就是使这些操作尽快完成。
根据机械原理，较大的存储设备比较小的存储设备运行的慢，而快速设备的造价远高于同类的低速设备。
一个寄存器文件只存储几百字节，而主存存放几十亿字节。针对处理器和主存之间的差异，采用了更小更快的存储设备，高速缓存存储器，存放近期可能用到的数据。

## 1.6 存储设备形成层次结构
在处理器和较大较慢的设备（如主存）之间插入一个更小更快的存储设备（cache）已经成为一个普遍的概念。
实际上，在计算机系统中的存储设备都被组织成一个*存储器层次结构*。
存储器层次结构的主要思想是上一层的存储器作为第一层存储器的高速缓存。

## 1.7 操作系统管理硬件





### 系统中的所有信息都是由bit串构成（明文->编码->底层01），信息的解释取决于具体的context

### C程序编译过程：预处理->编译->汇编->链接

### 这一章抛出了很多值得想象的问题：
* switch 语句是否比一系列的if then else 高效的多？
* 一个函数调用的开销是多少？
* while循环比for高效？
* 指针引用比数组引用更高效吗？
* 为何将循环求和的结果放到一个本地变量中，比将其放到一个通过引用传递过来的参数中相比，运行速度快很多呢？
* 为何只是重新排列算术表达式中的括号，既可以让一个函数运行快很多呢？
* 静态变量和全局变量的区别？
* 在不同的C文件中定义相同的两个全局变量，会发生什么？
* 静态库和动态库的区别？
* 在命令行上制定链接库，其顺序有何影响？
* 有些连接错误为何直到运行时才出现？

### 操作系统的抽象：进程，虚拟存储器，文件
* 进程线程的区别？
* 虚拟地址空间的每个区的含义，结构？
* 本地磁盘可以看做远程文件系统的高速缓存

### 利用hello.c的运行过程，漫游了在不同组件直接的通信复制过程，体现了缓存的重要性
[hello.c](hello.c)

### 抽象的重要性
指令集结构提供了对实际处理器硬件的抽象，使用这个抽象，机器代码程序员可视自己的程序运行在一个一次只执行一条指令的处理器上。
而底层的硬件比抽象的指令集要复杂精细的多，他并行执行多条指令，但是总是与那个简单有序的模型保持一致。





