[TOC]
# 1 计算机系统漫游
## 1.1 信息就是位+上下文
源程序实际上就是一由0和1组成的位（又成为比特）序列，8个位成一组，成为字节。字节表达程序中的字符。

## 1.2 程序被其它程序翻译成不同的格式
C程序编译过程：预处理->编译->汇编->链接

## 1.3 了解编译系统如何工作的益处
* 优化程序性能
* 理解链接时出现的错误
* 避免安全漏洞

## 1.4 处理器读并解析存储在内存中的指令
理解运行hello程序时发生了什么？
* 系统的硬件组成
1. 总线：贯穿整个系统的一组电子管道
2. I/O设备：是系统与外部世界的联系通道
3. 主存：临时存储设备
4. 处理器：解释存储在主存中的指令的引擎
* 运行hello程序
1. 初始时，从键盘上读取hello命令，shell程序将字符读入寄存器，再把它放到内存中
2. 当敲回车时，shell程序知道输入完毕。然后执行的hello文件，这些命令将目标文件的代码和数据从磁盘复制到内存
3. 一旦目标文件中的代码和数据加载到主存，处理器就开始执行程序中的main。将字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备

## 1.5 高速缓存至关重要（cache）
示例揭示了一个重要的问题，即系统花费了大量时间把信息从一个地方挪到另外一个地方。
程序的机器指令最初是放在磁盘上，程序加载时，被复制到主存；当处理器运行程序时，指令从主存复制到处理器。
因此，系统设计者的一个主要目标就是使这些操作尽快完成。
根据机械原理，较大的存储设备比较小的存储设备运行的慢，而快速设备的造价远高于同类的低速设备。
一个寄存器文件只存储几百字节，而主存存放几十亿字节。针对处理器和主存之间的差异，采用了更小更快的存储设备，高速缓存存储器，存放近期可能用到的数据。

## 1.6 存储设备形成层次结构
在处理器和较大较慢的设备（如主存）之间插入一个更小更快的存储设备（cache）已经成为一个普遍的概念。
实际上，在计算机系统中的存储设备都被组织成一个**存储器层次结构**。
存储器层次结构的主要思想是上一层的存储器作为第一层存储器的高速缓存。

## 1.7 操作系统管理硬件
操作系统有两个基本功能：
1 防止硬件被失控的应用程序滥用
2 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备
操作系统通过进程、虚拟内存和文件这几个基本的抽象概念来实现这两个功能
进程：
进程是操作系统对一个正在运行的程序的一种抽象。
操作系统保持跟踪进程运行所需的所有状态信息，这种状态也就是上下文。
线程：
一个进程实际上可以由多个成为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局变量
虚拟内存：
虚拟内存是你一个抽象的概念，它为每个进程提供了一个假象，即每个进程都在独占的使用主存。
每个进程看到的内存都是一样的，称为虚拟地址空间。
文件：
文件就是字节序列

## 1.8 系统之间利用网络通信
web服务器

## 1.9 重要主题
Amdahl定律

## 1.10 小结
计算机系统是由硬件和软件组成的。
计算机内部的信息被表示为一组组的位，它们根据上下文有不同的解释方式。
程序被其他程序翻译成不同的形式，开始是ASCII文本，然后被编译器和链接器翻译成二进制可执行文件。
处理器读取并解释存放在主存里的二进制指令。
由于计算机花费大量时间在内存、I/O设备和CPU寄存器之间复制数据，所以将系统中存储设备划分成层次结构。
操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象：文件、进程、虚拟内存



### 系统中的所有信息都是由bit串构成（明文->编码->底层01），信息的解释取决于具体的context

### C程序编译过程：预处理->编译->汇编->链接

### 这一章抛出了很多值得想象的问题：
* switch 语句是否比一系列的if then else 高效的多？
* 一个函数调用的开销是多少？
* while循环比for高效？
* 指针引用比数组引用更高效吗？
* 为何将循环求和的结果放到一个本地变量中，比将其放到一个通过引用传递过来的参数中相比，运行速度快很多呢？
* 为何只是重新排列算术表达式中的括号，既可以让一个函数运行快很多呢？
* 静态变量和全局变量的区别？
* 在不同的C文件中定义相同的两个全局变量，会发生什么？
* 静态库和动态库的区别？
* 在命令行上制定链接库，其顺序有何影响？
* 有些连接错误为何直到运行时才出现？

### 利用hello.c的运行过程，漫游了在不同组件直接的通信复制过程，体现了缓存的重要性
[hello.c](hello.c)



